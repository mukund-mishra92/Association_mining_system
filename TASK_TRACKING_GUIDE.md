# 🔄 Server-Side Service Call Completion Tracking

## 📋 Overview

Your Association Rule Mining API now supports **comprehensive task tracking** to monitor service call completion. Here are all the methods available:

## 🚀 Methods to Track Service Completion

### 1. **Task ID Based Tracking** ⭐ (Recommended)

When you start a mining operation, you get a `task_id` that you can use to track progress:

```python
# Start a task
response = requests.post("http://localhost:8000/mine-rules", json={
    "days_back": 30,
    "use_enhanced_mining": True,
    "time_weighting_method": "exponential_decay"
})

task_id = response.json()['task_id']

# Check task status
status_response = requests.get(f"http://localhost:8000/task/{task_id}")
task_info = status_response.json()

print(f"Status: {task_info['status']}")  # pending, running, completed, failed, cancelled
print(f"Progress: {task_info['progress']:.1%}")  # 0% to 100%
print(f"Message: {task_info['message']}")
```

### 2. **Database Completion Check** 📊

Check if recommendations were generated by querying the database:

```python
def check_mining_completion():
    """Check if mining completed by looking for recommendations"""
    try:
        from app.utils.config import config
        import mysql.connector
        
        conn = mysql.connector.connect(
            host=config.DB_HOST,
            user=config.DB_USER,
            password=config.DB_PASSWORD,
            database=config.DB_NAME
        )
        cursor = conn.cursor()
        
        # Check if recommendations table exists and has data
        cursor.execute(f"SHOW TABLES LIKE '{config.RECOMMENDATIONS_TABLE}'")
        table_exists = cursor.fetchone() is not None
        
        if table_exists:
            cursor.execute(f"SELECT COUNT(*) FROM {config.RECOMMENDATIONS_TABLE}")
            count = cursor.fetchone()[0]
            return count > 0, count
        
        return False, 0
        
    except Exception as e:
        print(f"Error checking database: {e}")
        return False, 0
```

### 3. **Server Logs Monitoring** 📝

Monitor server logs for completion messages:

```bash
# In your server terminal, look for these log messages:
INFO:app.api.endpoints:Mining completed: 1234 recommendations saved
ERROR:app.api.endpoints:Error in mining task: ...
```

### 4. **Running Tasks Check** 🏃‍♂️

Check if any mining tasks are currently running:

```python
# Get all running tasks
response = requests.get("http://localhost:8000/tasks/running")
running_tasks = response.json()

if running_tasks['count'] == 0:
    print("✅ No tasks are currently running")
else:
    print(f"🔄 {running_tasks['count']} tasks still running")
    for task in running_tasks['running_tasks']:
        print(f"  • {task['task_id']}: {task['progress']:.1%} - {task['message']}")
```

### 5. **Polling with Timeout** ⏰

Implement smart polling with timeout:

```python
def wait_for_task_completion(task_id, timeout_seconds=300, poll_interval=10):
    """Wait for task completion with timeout"""
    import time
    
    start_time = time.time()
    
    while (time.time() - start_time) < timeout_seconds:
        try:
            response = requests.get(f"http://localhost:8000/task/{task_id}")
            if response.status_code == 200:
                data = response.json()
                status = data['status']
                
                if status in ['completed', 'failed', 'cancelled']:
                    return status, data
                
                print(f"⏳ Progress: {data['progress']:.1%} - {data['message']}")
                
            time.sleep(poll_interval)
            
        except Exception as e:
            print(f"❌ Error checking status: {e}")
            break
    
    return 'timeout', None

# Usage
status, result = wait_for_task_completion('your-task-id', timeout_seconds=180)
```

## 📊 API Endpoints for Status Tracking

| Endpoint | Method | Purpose |
|----------|--------|---------|
| `/mine-rules` | POST | Start mining (returns task_id) |
| `/task/{task_id}` | GET | Get specific task status |
| `/tasks` | GET | Get all tasks |
| `/tasks/running` | GET | Get only running tasks |
| `/task/{task_id}` | DELETE | Cancel a task |
| `/tasks/cleanup` | POST | Clean up old tasks |

## 🔍 Task Status Values

- **`pending`** - Task created but not started yet
- **`running`** - Task is currently executing
- **`completed`** - Task finished successfully
- **`failed`** - Task encountered an error
- **`cancelled`** - Task was manually cancelled

## 📈 Progress Tracking

Tasks report progress from 0.0 to 1.0 (0% to 100%) with descriptive messages:

- `0.1` (10%) - "Connecting to database..."
- `0.2` (20%) - "Fetching order data..."
- `0.4` (40%) - "Running association rule mining..."
- `0.8` (80%) - "Processing recommendations..."
- `0.9` (90%) - "Saving recommendations to database..."
- `1.0` (100%) - "Mining completed: X recommendations saved"

## 🛠️ Integration Examples

### Flask/FastAPI Integration

```python
from app.services.task_manager import task_manager

# In your API endpoint
@app.post("/start-mining")
def start_mining():
    task_id = task_manager.create_task("mining")
    # Start background task...
    return {"task_id": task_id}

@app.get("/status/{task_id}")
def get_status(task_id: str):
    task = task_manager.get_task(task_id)
    return task.to_dict() if task else {"error": "Task not found"}
```

### Frontend Integration (JavaScript)

```javascript
// Start mining
const response = await fetch('/mine-rules', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ days_back: 30, use_enhanced_mining: true })
});
const { task_id } = await response.json();

// Poll for completion
const pollStatus = async () => {
    const statusResponse = await fetch(`/task/${task_id}`);
    const status = await statusResponse.json();
    
    if (status.status === 'completed') {
        console.log('✅ Mining completed!');
        return true;
    } else if (status.status === 'failed') {
        console.log('❌ Mining failed:', status.error);
        return true;
    }
    
    console.log(`Progress: ${(status.progress * 100).toFixed(1)}%`);
    return false;
};

// Poll every 5 seconds
const interval = setInterval(async () => {
    if (await pollStatus()) {
        clearInterval(interval);
    }
}, 5000);
```

## ⚠️ Best Practices

1. **Always use task IDs** for reliable tracking
2. **Implement timeouts** to avoid infinite waiting
3. **Handle network errors** gracefully
4. **Clean up old tasks** periodically
5. **Monitor server logs** for debugging
6. **Use appropriate poll intervals** (5-10 seconds)

## 🎯 Testing Your Setup

Run the test notebook cell I created above to see all tracking methods in action!

```python
# The test will:
# 1. Start a mining task and get task_id
# 2. Monitor progress in real-time
# 3. Show final completion status
# 4. Display all tasks in the system
```

Your system now provides **enterprise-grade task tracking** with real-time progress monitoring! 🚀